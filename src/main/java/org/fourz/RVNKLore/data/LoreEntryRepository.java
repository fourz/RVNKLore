package org.fourz.RVNKLore.data;

import org.fourz.RVNKLore.RVNKLore;
import org.fourz.RVNKLore.debug.LogManager;
import org.fourz.RVNKLore.data.dto.LoreEntryDTO;
import org.fourz.RVNKLore.data.dto.LoreSubmissionDTO;
import org.fourz.RVNKLore.lore.LoreEntry;
import java.util.concurrent.CompletableFuture;
import java.util.List;
import java.util.Map;
import java.sql.Timestamp;
import org.json.simple.JSONObject;
import org.bukkit.Location;

/**
 * Repository for Lore Entry database operations
 * 
 * This repository manages the creation, retrieval, and updating of lore entries
 * using the lore_entry, lore_submission, and specialized tables (e.g., lore_item).
 * All operations are asynchronous using CompletableFuture.
 */
public class LoreEntryRepository {
    protected final RVNKLore plugin; // Used by subclasses
    private final LogManager logger;
    private final DatabaseManager databaseManager;

    public LoreEntryRepository(RVNKLore plugin, DatabaseManager databaseManager) {
        this.plugin = plugin;
        this.logger = LogManager.getInstance(plugin, "LoreEntryRepository");
        this.databaseManager = databaseManager;
    }

    /**
     * Add a new lore entry to the database asynchronously with submission and specialized records.
     * 
     * This method creates a new lore entry with its initial submission version.
     *
     * @param entry The lore entry to add
     * @return CompletableFuture of true if successful, false otherwise
     */
    public CompletableFuture<Boolean> addLoreEntry(LoreEntry entry) {
        // Convert LoreEntry to DTO
        LoreEntryDTO entryDto = new LoreEntryDTO();
        try {
            entryDto.setId(Integer.parseInt(entry.getId())); // Use entry's string ID as int
        } catch (NumberFormatException e) {
            // Use -1 as a temporary ID since it's generated by the database
            entryDto.setId(-1);
        }
        entryDto.setEntryType(entry.getType().name());
        entryDto.setName(entry.getName());
        entryDto.setDescription(entry.getDescription());
        entryDto.setCreatedAt(entry.getCreatedAt());
        entryDto.setUpdatedAt(entry.getCreatedAt()); // Initially same as created
        
        // Initial submission
        LoreSubmissionDTO submissionDto = new LoreSubmissionDTO();
        submissionDto.setEntryId(-1); // Will be set by DatabaseManager after entry creation
        submissionDto.setSubmitterUuid(entry.getSubmittedBy() != null ? entry.getSubmittedBy() : "Server");
        submissionDto.setCreatedBy(entry.getSubmittedBy() != null ? entry.getSubmittedBy() : "Server");
        submissionDto.setContent(buildSubmissionContent(entry));
        submissionDto.setStatus("PENDING");
        submissionDto.setApprovalStatus("PENDING");
        submissionDto.setVisibility("PUBLIC");
        submissionDto.setCurrentVersion(true);
        submissionDto.setContentVersion(1);
        submissionDto.setCreatedAt(entry.getCreatedAt());
        submissionDto.setUpdatedAt(entry.getCreatedAt());
        submissionDto.setSubmissionDate(entry.getCreatedAt());
        
        // Add using DatabaseManager's async method
        return databaseManager.saveLoreEntry(entryDto)
            .thenCompose(entryId -> {
                if (entryId <= 0) {
                    logger.error("Failed to save lore entry", new RuntimeException("Invalid entry ID returned: " + entryId));
                    return CompletableFuture.completedFuture(false);
                }
                submissionDto.setEntryId(entryId);
                return databaseManager.saveLoreSubmission(submissionDto)
                    .thenApply(submissionId -> submissionId > 0);
            });
    }

    /**
     * Build JSON content for lore submission with proper type safety
     */
    @SuppressWarnings("unchecked")
    private String buildSubmissionContent(LoreEntry entry) {
        JSONObject content = new JSONObject();
        content.put("description", entry.getDescription());
        content.put("nbt_data", entry.getNbtData());
        
        // Include location if available
        Location loc = entry.getLocation();
        if (loc != null) {
            JSONObject locJson = new JSONObject();
            locJson.put("world", loc.getWorld().getName());
            locJson.put("x", Double.toString(loc.getX()));
            locJson.put("y", Double.toString(loc.getY()));
            locJson.put("z", Double.toString(loc.getZ()));
            content.put("location", locJson);
        }
        
        // Include metadata
        Map<String, String> metadata = entry.getAllMetadata();
        if (metadata != null) {
            metadata.forEach((key, value) -> content.put(key, value));
        }
        
        return content.toJSONString();
    }

    /**
     * Update a lore entry and its submission asynchronously
     * 
     * @param entry The lore entry to update
     * @return CompletableFuture of true if successful, false otherwise
     */
    public CompletableFuture<Boolean> updateLoreEntry(LoreEntry entry) {
        // Convert to DTOs
        LoreEntryDTO entryDto = new LoreEntryDTO();
        try {
            entryDto.setId(Integer.parseInt(entry.getId()));
        } catch (NumberFormatException e) {
            logger.error("Invalid entry ID format", e);
            return CompletableFuture.completedFuture(false);
        }
        entryDto.setEntryType(entry.getType().name());
        entryDto.setName(entry.getName());
        entryDto.setDescription(entry.getDescription());
        entryDto.setCreatedAt(entry.getCreatedAt());
        entryDto.setUpdatedAt(new Timestamp(System.currentTimeMillis()));
        
        // Create new submission version
        LoreSubmissionDTO submissionDto = new LoreSubmissionDTO();
        try {
            submissionDto.setEntryId(Integer.parseInt(entry.getId()));
        } catch (NumberFormatException e) {
            logger.error("Invalid entry ID format for submission", e);
            return CompletableFuture.completedFuture(false);
        }
        submissionDto.setSubmitterUuid(entry.getSubmittedBy() != null ? entry.getSubmittedBy() : "Server");
        submissionDto.setCreatedBy(entry.getSubmittedBy() != null ? entry.getSubmittedBy() : "Server");
        submissionDto.setContent(buildSubmissionContent(entry));
        submissionDto.setStatus("PENDING");
        submissionDto.setApprovalStatus("PENDING");
        submissionDto.setVisibility("PUBLIC");
        submissionDto.setCurrentVersion(true);
        // Version will be incremented by DatabaseManager
        submissionDto.setContentVersion(-1);
        submissionDto.setCreatedAt(new Timestamp(System.currentTimeMillis()));
        submissionDto.setUpdatedAt(submissionDto.getCreatedAt());
        submissionDto.setSubmissionDate(submissionDto.getCreatedAt());

        // Update the entry first
        return databaseManager.saveLoreEntry(entryDto)
            .thenCompose(savedId -> {
                if (savedId <= 0) {
                    logger.error("Failed to update lore entry", new RuntimeException("Update failed for entry: " + entry.getId()));
                    return CompletableFuture.completedFuture(false);
                }
                // Save the new submission (DatabaseManager will handle setting old version to not current)
                return databaseManager.saveLoreSubmission(submissionDto)
                    .thenApply(submissionId -> submissionId > 0);
            });
    }

    /**
     * Search lore entries by keyword in name or description asynchronously
     * 
     * @param keyword The keyword to search for
     * @return CompletableFuture with a list of matching lore entries as DTOs
     */
    public CompletableFuture<List<LoreEntryDTO>> searchLoreEntries(String keyword) {
        return databaseManager.searchLoreEntries(keyword);
    }

    /**
     * Get the total count of lore entries asynchronously
     *
     * @return CompletableFuture containing the count of all lore entries
     */
    public CompletableFuture<Integer> getEntryCount() {
        return databaseManager.getAllLoreEntries()
            .thenApply(entries -> entries != null ? entries.size() : 0);
    }
}
